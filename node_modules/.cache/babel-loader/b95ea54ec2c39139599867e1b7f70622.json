{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/bryan/Documents/HUPoker/src/components/hand.jsx\";\nimport React, { Component } from \"react\";\nimport { evaluateHoleCards, evaluateFlop, evaluateRiver, evaluateTurn } from \"./HandEvaluator.js\"; // Component to represent each player's hand\n\nclass Hand extends Component {\n  constructor(props) {\n    super(props);\n\n    this.displayHand = (dealHoleCards, dealFlop, dealTurn, dealRiver, holeCards, flop, turn, river) => {\n      // If hole cards haven't been dealt yet don't display anything\n      if (!dealHoleCards) return null; // If flop hasn't been dealt yet only evaluate hole cards\n      else if (!dealFlop) {\n          return evaluateHoleCards(holeCards);\n        } // If turn hasn't been dealt yet only evaluate hole cards and flop\n        else if (!dealTurn) {\n            return evaluateFlop(holeCards, flop)[0];\n          } // If river hasn't been dealt yet only evaluate hole cards, flop, and turn\n          else if (!dealRiver) {\n              return evaluateTurn(holeCards, flop, turn)[0];\n            } // Otherwise evaluate all cards\n            else {\n                return evaluateRiver(holeCards, flop, turn, river)[0];\n              }\n    };\n\n    this.state = {\n      holeCards: this.props.holeCards,\n      flop: this.props.flop,\n      turn: this.props.turn,\n      river: this.props.river,\n      values: [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", \"J\", \"Q\", \"K\", \"A\"],\n      rank: [\"High card\", \"Pair\", \"Two pair\", \"Three of a kind\", \"Straight\", \"Flush\", \"Full House\", \"Four of a kind\", \"Straight Flush\", \"Royal Flush\"]\n    };\n  } // Evaluate strength of hole cards\n  // evaluateHoleCards = (holeCards) => {\n  //   var card1 = holeCards[0].code;\n  //   var card2 = holeCards[1].code;\n  //   if (card1.substring(0, 1) === card2.substring(0, 1)) return \"Pair\";\n  //   else {\n  //     return \"High card\";\n  //   }\n  // };\n  // // Evaluate any given 5 card hand\n  // evaluateFiveCardHand = (cards) => {\n  //   if (this.isRoyalFlush(cards)) return 9;\n  //   if (this.isStraightFlush(cards)) return 8;\n  //   if (this.isFourOfAKind(cards)) return 7;\n  //   if (this.isFullHouse(cards)) return 6;\n  //   if (this.isFlush(cards)) return 5;\n  //   if (this.isStraight(cards)) return 4;\n  //   if (this.isTrips(cards)) return 3;\n  //   if (this.isTwoPair(cards)) return 2;\n  //   if (this.isPair(cards)) return 1;\n  //   else return 0;\n  // };\n  // // Evaluate hand after flop\n  // evaluateFlop = (holeCards, flop) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   return this.state.rank[this.evaluateFiveCardHand(cards)];\n  // };\n  // // Evaluate hand after turn\n  // evaluateTurn = (holeCards, flop, turn) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   cards.push(turn[0].code);\n  //   // Loop through possible 5 hand combos and return hand with highest strength\n  //   var high = 0;\n  //   for (var k = 0; k < 6; k++) {\n  //     var tempCards = cards.slice();\n  //     tempCards.splice(k, 1);\n  //     if (this.evaluateFiveCardHand(tempCards) > high)\n  //       high = this.evaluateFiveCardHand(tempCards);\n  //   }\n  //   return this.state.rank[high];\n  // };\n  // // Evaluate hand after river\n  // evaluateRiver = (holeCards, flop, turn, river) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   cards.push(turn[0].code);\n  //   cards.push(river[0].code);\n  //   var high = 0;\n  //   // Loop through possible 5 hand combos and return hand with highest strength\n  //   for (var k = 0; k < cards.length - 1; k++) {\n  //     for (var l = 1; l < cards.length; l++) {\n  //       var tempCards = cards.slice();\n  //       tempCards.splice(k, 1);\n  //       tempCards.splice(l - 1, 1);\n  //       if (this.evaluateFiveCardHand(tempCards) > high)\n  //         high = this.evaluateFiveCardHand(tempCards);\n  //     }\n  //   }\n  //   return this.state.rank[high];\n  // };\n  // // Check if given cards represent a royal flush\n  // isRoyalFlush(cards) {\n  //   // Must be a straight flush and contain an Ace and 10\n  //   if (this.isStraightFlush(cards)) {\n  //     for (var i = 0; i < cards.length; i++) {\n  //       if (cards[i].includes(\"A\")) {\n  //         for (var j = 0; j < cards.length; j++) {\n  //           if (cards[j].includes(\"0\")) {\n  //             return true;\n  //           }\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent a straight flush\n  // isStraightFlush(cards) {\n  //   // Must be a straight and a flush\n  //   if (this.isFlush(cards) && this.isStraight(cards)) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent a four of a kind\n  // isFourOfAKind(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be four of a kind if size of set is 2\n  //   if (set.size === 2) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 4 times then it is four of a kind\n  //     for (var k = 0; k < uniqueVals.length; k++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[k]) valCount++;\n  //         if (valCount === 4) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent a full house\n  // isFullHouse(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be full house if size of set is 2\n  //   if (set.size === 2) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 3 times then it is full house\n  //     for (var k = 0; k < uniqueVals.length; k++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[k]) valCount++;\n  //         if (valCount === 3) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent a flush\n  // isFlush(cards) {\n  //   // Add all suits of the cards to array 'suits'\n  //   var suits = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     suits.push(cards[i].substr(1));\n  //   }\n  //   // Create a set from array 'suits'\n  //   var set = new Set(suits);\n  //   // Can only be flush if size of set is 1\n  //   if (set.size === 1) {\n  //     return true;\n  //   } else return false;\n  // }\n  // // Check if given cards represent a straight\n  // isStraight(cards) {\n  //   // Add indices of values of all cards to array 'indices'\n  //   var indices = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     indices.push(this.state.values.indexOf(cards[i].substr(0, 1)));\n  //   }\n  //   // Sort 'indices'\n  //   indices.sort(function (a, b) {\n  //     return a - b;\n  //   });\n  //   // Check if it is a wheel straight\n  //   var wheel = [0, 1, 2, 3, 12];\n  //   if (\n  //     indices.length === wheel.length &&\n  //     indices.every((value, index) => value === wheel[index])\n  //   ) {\n  //     return true;\n  //   }\n  //   // If not a wheel straight determine if it's a regular straight\n  //   // In order to be a regular straight value at index + 1 must be 1 greater than value at index\n  //   for (var j = 0; j < indices.length - 1; j++) {\n  //     if (indices[j] + 1 !== indices[j + 1]) return false;\n  //   }\n  //   return true;\n  // }\n  // // Check if given cards represent trips\n  // isTrips(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var k = 0; k < cards.length; k++) {\n  //     vals.push(cards[k].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be trips if size of set is 3\n  //   if (set.size === 3) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 3 times then it is trips\n  //     for (var i = 0; i < uniqueVals.length; i++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[i]) valCount++;\n  //         if (valCount === 3) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent two pair\n  // isTwoPair(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be two pair of size of set is 3\n  //   if (set.size === 3) {\n  //     // Since we already checked for trips in function that called this function, the only other hand with set of size 3 is two pair\n  //     return true;\n  //   }\n  //   return false;\n  // }\n  // // Check if given cards represent a pair\n  // isPair(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be a pair of size of set is 4\n  //   if (set.size === 4) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n  // Method to display hand strength\n\n\n  render() {\n    const {\n      dealHoleCards,\n      dealFlop,\n      dealTurn,\n      dealRiver,\n      holeCards,\n      flop,\n      turn,\n      river\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: /*#__PURE__*/_jsxDEV(\"span\", {\n        children: dealHoleCards ? /*#__PURE__*/_jsxDEV(\"p\", {\n          children: this.displayHand(dealHoleCards, dealFlop, dealTurn, dealRiver, holeCards, flop, turn, river)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 341,\n          columnNumber: 13\n        }, this) : null\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 338,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nexport default Hand;","map":{"version":3,"sources":["/Users/bryan/Documents/HUPoker/src/components/hand.jsx"],"names":["React","Component","evaluateHoleCards","evaluateFlop","evaluateRiver","evaluateTurn","Hand","constructor","props","displayHand","dealHoleCards","dealFlop","dealTurn","dealRiver","holeCards","flop","turn","river","state","values","rank","render"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SACEC,iBADF,EAEEC,YAFF,EAGEC,aAHF,EAIEC,YAJF,QAKO,oBALP,C,CAOA;;AACA,MAAMC,IAAN,SAAmBL,SAAnB,CAA6B;AAC3BM,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;;AADiB,SA6RnBC,WA7RmB,GA6RL,CACZC,aADY,EAEZC,QAFY,EAGZC,QAHY,EAIZC,SAJY,EAKZC,SALY,EAMZC,IANY,EAOZC,IAPY,EAQZC,KARY,KAST;AACH;AACA,UAAI,CAACP,aAAL,EAAoB,OAAO,IAAP,CAApB,CACA;AADA,WAEK,IAAI,CAACC,QAAL,EAAe;AAClB,iBAAOT,iBAAiB,CAACY,SAAD,CAAxB;AACD,SAFI,CAGL;AAHK,aAIA,IAAI,CAACF,QAAL,EAAe;AAClB,mBAAOT,YAAY,CAACW,SAAD,EAAYC,IAAZ,CAAZ,CAA8B,CAA9B,CAAP;AACD,WAFI,CAGL;AAHK,eAIA,IAAI,CAACF,SAAL,EAAgB;AACnB,qBAAOR,YAAY,CAACS,SAAD,EAAYC,IAAZ,EAAkBC,IAAlB,CAAZ,CAAoC,CAApC,CAAP;AACD,aAFI,CAGL;AAHK,iBAIA;AACH,uBAAOZ,aAAa,CAACU,SAAD,EAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,KAAxB,CAAb,CAA4C,CAA5C,CAAP;AACD;AACF,KAzTkB;;AAEjB,SAAKC,KAAL,GAAa;AACXJ,MAAAA,SAAS,EAAE,KAAKN,KAAL,CAAWM,SADX;AAEXC,MAAAA,IAAI,EAAE,KAAKP,KAAL,CAAWO,IAFN;AAGXC,MAAAA,IAAI,EAAE,KAAKR,KAAL,CAAWQ,IAHN;AAIXC,MAAAA,KAAK,EAAE,KAAKT,KAAL,CAAWS,KAJP;AAKXE,MAAAA,MAAM,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,CALG;AAMXC,MAAAA,IAAI,EAAE,CACJ,WADI,EAEJ,MAFI,EAGJ,UAHI,EAIJ,iBAJI,EAKJ,UALI,EAMJ,OANI,EAOJ,YAPI,EAQJ,gBARI,EASJ,gBATI,EAUJ,aAVI;AANK,KAAb;AAmBD,GAtB0B,CAwB3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AA+BAC,EAAAA,MAAM,GAAG;AACP,UAAM;AACJX,MAAAA,aADI;AAEJC,MAAAA,QAFI;AAGJC,MAAAA,QAHI;AAIJC,MAAAA,SAJI;AAKJC,MAAAA,SALI;AAMJC,MAAAA,IANI;AAOJC,MAAAA,IAPI;AAQJC,MAAAA;AARI,QASF,KAAKT,KATT;AAUA,wBACE,QAAC,KAAD,CAAO,QAAP;AAAA,6BACE;AAAA,kBACGE,aAAa,gBACZ;AAAA,oBACG,KAAKD,WAAL,CACCC,aADD,EAECC,QAFD,EAGCC,QAHD,EAICC,SAJD,EAKCC,SALD,EAMCC,IAND,EAOCC,IAPD,EAQCC,KARD;AADH;AAAA;AAAA;AAAA;AAAA,gBADY,GAaV;AAdN;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA,YADF;AAoBD;;AA3V0B;;AA8V7B,eAAeX,IAAf","sourcesContent":["import React, { Component } from \"react\";\nimport {\n  evaluateHoleCards,\n  evaluateFlop,\n  evaluateRiver,\n  evaluateTurn,\n} from \"./HandEvaluator.js\";\n\n// Component to represent each player's hand\nclass Hand extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      holeCards: this.props.holeCards,\n      flop: this.props.flop,\n      turn: this.props.turn,\n      river: this.props.river,\n      values: [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", \"J\", \"Q\", \"K\", \"A\"],\n      rank: [\n        \"High card\",\n        \"Pair\",\n        \"Two pair\",\n        \"Three of a kind\",\n        \"Straight\",\n        \"Flush\",\n        \"Full House\",\n        \"Four of a kind\",\n        \"Straight Flush\",\n        \"Royal Flush\",\n      ],\n    };\n  }\n\n  // Evaluate strength of hole cards\n  // evaluateHoleCards = (holeCards) => {\n  //   var card1 = holeCards[0].code;\n  //   var card2 = holeCards[1].code;\n  //   if (card1.substring(0, 1) === card2.substring(0, 1)) return \"Pair\";\n  //   else {\n  //     return \"High card\";\n  //   }\n  // };\n\n  // // Evaluate any given 5 card hand\n  // evaluateFiveCardHand = (cards) => {\n  //   if (this.isRoyalFlush(cards)) return 9;\n  //   if (this.isStraightFlush(cards)) return 8;\n  //   if (this.isFourOfAKind(cards)) return 7;\n  //   if (this.isFullHouse(cards)) return 6;\n  //   if (this.isFlush(cards)) return 5;\n  //   if (this.isStraight(cards)) return 4;\n  //   if (this.isTrips(cards)) return 3;\n  //   if (this.isTwoPair(cards)) return 2;\n  //   if (this.isPair(cards)) return 1;\n  //   else return 0;\n  // };\n\n  // // Evaluate hand after flop\n  // evaluateFlop = (holeCards, flop) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   return this.state.rank[this.evaluateFiveCardHand(cards)];\n  // };\n\n  // // Evaluate hand after turn\n  // evaluateTurn = (holeCards, flop, turn) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   cards.push(turn[0].code);\n  //   // Loop through possible 5 hand combos and return hand with highest strength\n  //   var high = 0;\n  //   for (var k = 0; k < 6; k++) {\n  //     var tempCards = cards.slice();\n  //     tempCards.splice(k, 1);\n  //     if (this.evaluateFiveCardHand(tempCards) > high)\n  //       high = this.evaluateFiveCardHand(tempCards);\n  //   }\n  //   return this.state.rank[high];\n  // };\n\n  // // Evaluate hand after river\n  // evaluateRiver = (holeCards, flop, turn, river) => {\n  //   var cards = [];\n  //   for (var i = 0; i < holeCards.length; i++) {\n  //     cards.push(holeCards[i].code);\n  //   }\n  //   for (var j = 0; j < flop.length; j++) {\n  //     cards.push(flop[j].code);\n  //   }\n  //   cards.push(turn[0].code);\n  //   cards.push(river[0].code);\n  //   var high = 0;\n  //   // Loop through possible 5 hand combos and return hand with highest strength\n  //   for (var k = 0; k < cards.length - 1; k++) {\n  //     for (var l = 1; l < cards.length; l++) {\n  //       var tempCards = cards.slice();\n  //       tempCards.splice(k, 1);\n  //       tempCards.splice(l - 1, 1);\n  //       if (this.evaluateFiveCardHand(tempCards) > high)\n  //         high = this.evaluateFiveCardHand(tempCards);\n  //     }\n  //   }\n  //   return this.state.rank[high];\n  // };\n\n  // // Check if given cards represent a royal flush\n  // isRoyalFlush(cards) {\n  //   // Must be a straight flush and contain an Ace and 10\n  //   if (this.isStraightFlush(cards)) {\n  //     for (var i = 0; i < cards.length; i++) {\n  //       if (cards[i].includes(\"A\")) {\n  //         for (var j = 0; j < cards.length; j++) {\n  //           if (cards[j].includes(\"0\")) {\n  //             return true;\n  //           }\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent a straight flush\n  // isStraightFlush(cards) {\n  //   // Must be a straight and a flush\n  //   if (this.isFlush(cards) && this.isStraight(cards)) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent a four of a kind\n  // isFourOfAKind(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be four of a kind if size of set is 2\n  //   if (set.size === 2) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 4 times then it is four of a kind\n  //     for (var k = 0; k < uniqueVals.length; k++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[k]) valCount++;\n  //         if (valCount === 4) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent a full house\n  // isFullHouse(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be full house if size of set is 2\n  //   if (set.size === 2) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 3 times then it is full house\n  //     for (var k = 0; k < uniqueVals.length; k++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[k]) valCount++;\n  //         if (valCount === 3) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent a flush\n  // isFlush(cards) {\n  //   // Add all suits of the cards to array 'suits'\n  //   var suits = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     suits.push(cards[i].substr(1));\n  //   }\n  //   // Create a set from array 'suits'\n  //   var set = new Set(suits);\n  //   // Can only be flush if size of set is 1\n  //   if (set.size === 1) {\n  //     return true;\n  //   } else return false;\n  // }\n\n  // // Check if given cards represent a straight\n  // isStraight(cards) {\n  //   // Add indices of values of all cards to array 'indices'\n  //   var indices = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     indices.push(this.state.values.indexOf(cards[i].substr(0, 1)));\n  //   }\n  //   // Sort 'indices'\n  //   indices.sort(function (a, b) {\n  //     return a - b;\n  //   });\n  //   // Check if it is a wheel straight\n  //   var wheel = [0, 1, 2, 3, 12];\n  //   if (\n  //     indices.length === wheel.length &&\n  //     indices.every((value, index) => value === wheel[index])\n  //   ) {\n  //     return true;\n  //   }\n  //   // If not a wheel straight determine if it's a regular straight\n  //   // In order to be a regular straight value at index + 1 must be 1 greater than value at index\n  //   for (var j = 0; j < indices.length - 1; j++) {\n  //     if (indices[j] + 1 !== indices[j + 1]) return false;\n  //   }\n  //   return true;\n  // }\n\n  // // Check if given cards represent trips\n  // isTrips(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var k = 0; k < cards.length; k++) {\n  //     vals.push(cards[k].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be trips if size of set is 3\n  //   if (set.size === 3) {\n  //     var uniqueVals = Array.from(set);\n  //     // If one of the elements occurs 3 times then it is trips\n  //     for (var i = 0; i < uniqueVals.length; i++) {\n  //       var valCount = 0;\n  //       for (var j = 0; j < vals.length; j++) {\n  //         if (vals[j] === uniqueVals[i]) valCount++;\n  //         if (valCount === 3) {\n  //           return true;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent two pair\n  // isTwoPair(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be two pair of size of set is 3\n  //   if (set.size === 3) {\n  //     // Since we already checked for trips in function that called this function, the only other hand with set of size 3 is two pair\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  // // Check if given cards represent a pair\n  // isPair(cards) {\n  //   // Add all the values of the cards to array 'vals'\n  //   var vals = [];\n  //   for (var i = 0; i < cards.length; i++) {\n  //     vals.push(cards[i].substr(0, 1));\n  //   }\n  //   // Create a set from array 'vals'\n  //   var set = new Set(vals);\n  //   // Can only be a pair of size of set is 4\n  //   if (set.size === 4) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  // Method to display hand strength\n  displayHand = (\n    dealHoleCards,\n    dealFlop,\n    dealTurn,\n    dealRiver,\n    holeCards,\n    flop,\n    turn,\n    river\n  ) => {\n    // If hole cards haven't been dealt yet don't display anything\n    if (!dealHoleCards) return null;\n    // If flop hasn't been dealt yet only evaluate hole cards\n    else if (!dealFlop) {\n      return evaluateHoleCards(holeCards);\n    }\n    // If turn hasn't been dealt yet only evaluate hole cards and flop\n    else if (!dealTurn) {\n      return evaluateFlop(holeCards, flop)[0];\n    }\n    // If river hasn't been dealt yet only evaluate hole cards, flop, and turn\n    else if (!dealRiver) {\n      return evaluateTurn(holeCards, flop, turn)[0];\n    }\n    // Otherwise evaluate all cards\n    else {\n      return evaluateRiver(holeCards, flop, turn, river)[0];\n    }\n  };\n\n  render() {\n    const {\n      dealHoleCards,\n      dealFlop,\n      dealTurn,\n      dealRiver,\n      holeCards,\n      flop,\n      turn,\n      river,\n    } = this.props;\n    return (\n      <React.Fragment>\n        <span>\n          {dealHoleCards ? (\n            <p>\n              {this.displayHand(\n                dealHoleCards,\n                dealFlop,\n                dealTurn,\n                dealRiver,\n                holeCards,\n                flop,\n                turn,\n                river\n              )}\n            </p>\n          ) : null}\n        </span>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Hand;\n"]},"metadata":{},"sourceType":"module"}