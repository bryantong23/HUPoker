[{"/Users/bryan/Documents/HUPoker/src/index.js":"1","/Users/bryan/Documents/HUPoker/src/reportWebVitals.js":"2","/Users/bryan/Documents/HUPoker/src/App.js":"3","/Users/bryan/Documents/HUPoker/src/components/playerBanner.jsx":"4","/Users/bryan/Documents/HUPoker/src/components/players.jsx":"5","/Users/bryan/Documents/HUPoker/src/components/card.jsx":"6","/Users/bryan/Documents/HUPoker/src/components/holeCards.jsx":"7","/Users/bryan/Documents/HUPoker/src/components/board.jsx":"8","/Users/bryan/Documents/HUPoker/src/components/hand.jsx":"9","/Users/bryan/Documents/HUPoker/src/components/HandEvaluator.js":"10"},{"size":543,"mtime":1607022090988,"results":"11","hashOfConfig":"12"},{"size":362,"mtime":1606943944805,"results":"13","hashOfConfig":"12"},{"size":31401,"mtime":1609906496388,"results":"14","hashOfConfig":"12"},{"size":2578,"mtime":1609899551421,"results":"15","hashOfConfig":"12"},{"size":663,"mtime":1607463400440,"results":"16","hashOfConfig":"12"},{"size":365,"mtime":1609905876306,"results":"17","hashOfConfig":"12"},{"size":380,"mtime":1607463372677,"results":"18","hashOfConfig":"12"},{"size":733,"mtime":1607463363096,"results":"19","hashOfConfig":"12"},{"size":2226,"mtime":1609354724220,"results":"20","hashOfConfig":"12"},{"size":24983,"mtime":1609899335423,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"13n84by",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"24"},"/Users/bryan/Documents/HUPoker/src/index.js",[],["44","45"],"/Users/bryan/Documents/HUPoker/src/reportWebVitals.js",[],"/Users/bryan/Documents/HUPoker/src/App.js",[],"/Users/bryan/Documents/HUPoker/src/components/playerBanner.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/players.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/card.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/holeCards.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/board.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/hand.jsx",[],"/Users/bryan/Documents/HUPoker/src/components/HandEvaluator.js",["46","47","48","49","50","51","52","53","54","55","56","57","58"],"var values = [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\", \"J\", \"Q\", \"K\", \"A\"];\nvar rank = [\n  \"High card\",\n  \"Pair\",\n  \"Two pair\",\n  \"Three of a kind\",\n  \"Straight\",\n  \"Flush\",\n  \"Full House\",\n  \"Four of a kind\",\n  \"Straight Flush\",\n  \"Royal Flush\",\n];\n\n// Evaluate strength of hole cards\nexport const evaluateHoleCards = (holeCards) => {\n  var card1 = holeCards[0].code;\n  var card2 = holeCards[1].code;\n  if (card1.substring(0, 1) === card2.substring(0, 1)) return \"Pair\";\n  else {\n    return \"High card\";\n  }\n};\n\n// Evaluate any given 5 card hand\nexport const evaluateFiveCardHand = (cards) => {\n  if (isRoyalFlush(cards)[0]) return [9, isRoyalFlush(cards)[1]];\n  if (isStraightFlush(cards)[0]) return [8, isStraightFlush(cards)[1]];\n  if (isFourOfAKind(cards)[0]) return [7, isFourOfAKind(cards)[1]];\n  if (isFullHouse(cards)[0]) return [6, isFullHouse(cards)[1]];\n  if (isFlush(cards)[0]) return [5, isFlush(cards)[1]];\n  if (isStraight(cards)[0]) return [4, isStraight(cards)[1]];\n  if (isTrips(cards)[0]) return [3, isTrips(cards)[1]];\n  if (isTwoPair(cards)[0]) return [2, isTwoPair(cards)[1]];\n  if (isPair(cards)[0]) return [1, isPair(cards)[1]];\n  else return [0, highCard(cards)];\n};\n\n// Get exact numerical hand strength\nexport const getHandStrength = (cards) => {};\n\n// Evaluate hand after flop\nexport const evaluateFlop = (holeCards, flop) => {\n  var cards = [];\n  for (var i = 0; i < holeCards.length; i++) {\n    cards.push(holeCards[i].code);\n  }\n  for (var j = 0; j < flop.length; j++) {\n    cards.push(flop[j].code);\n  }\n  const [handRank, score] = evaluateFiveCardHand(cards);\n  return [rank[handRank], score, cards];\n};\n\n// Evaluate hand after turn\nexport const evaluateTurn = (holeCards, flop, turn) => {\n  var cards = [];\n  for (var i = 0; i < holeCards.length; i++) {\n    cards.push(holeCards[i].code);\n  }\n  for (var j = 0; j < flop.length; j++) {\n    cards.push(flop[j].code);\n  }\n  cards.push(turn[0].code);\n  // Loop through possible 5 hand combos and return hand with highest strength\n  var highHand = 0;\n  var highScore = 0;\n  var bestCards = [];\n  for (var k = 0; k < 6; k++) {\n    var tempCards = cards.slice();\n    tempCards.splice(k, 1);\n    if (evaluateFiveCardHand(tempCards)[0] > highHand) {\n      highHand = evaluateFiveCardHand(tempCards)[0];\n      highScore = evaluateFiveCardHand(tempCards)[1];\n      bestCards = tempCards;\n    } else if (\n      evaluateFiveCardHand(tempCards)[0] === highHand &&\n      evaluateFiveCardHand(tempCards)[1] > highScore\n    ) {\n      highScore = evaluateFiveCardHand(tempCards)[1];\n      bestCards = tempCards;\n    }\n  }\n  return [rank[highHand], bestCards, highScore];\n};\n\n// Evaluate hand after river\nexport const evaluateRiver = (holeCards, flop, turn, river) => {\n  var cards = [];\n  for (var i = 0; i < holeCards.length; i++) {\n    cards.push(holeCards[i].code);\n  }\n  for (var j = 0; j < flop.length; j++) {\n    cards.push(flop[j].code);\n  }\n  cards.push(turn[0].code);\n  cards.push(river[0].code);\n  var highHand = 0;\n  var highScore = 0;\n  var bestCards = [];\n  // Loop through possible 5 hand combos and return hand with highest strength\n  for (var k = 0; k < cards.length - 1; k++) {\n    for (var l = 1; l < cards.length; l++) {\n      var tempCards = cards.slice();\n      tempCards.splice(k, 1);\n      tempCards.splice(l - 1, 1);\n      if (evaluateFiveCardHand(tempCards)[1] > highScore) {\n        highHand = evaluateFiveCardHand(tempCards)[0];\n        highScore = evaluateFiveCardHand(tempCards)[1];\n        bestCards = tempCards;\n      } else if (\n        evaluateFiveCardHand(tempCards)[0] === highHand &&\n        evaluateFiveCardHand(tempCards)[1] > highScore\n      ) {\n        highScore = evaluateFiveCardHand(tempCards)[1];\n        bestCards = tempCards;\n      }\n    }\n  }\n  return [rank[highHand], bestCards, highScore];\n};\n\n// Check if given cards represent a royal flush\nexport const isRoyalFlush = (cards) => {\n  let score = 0;\n  // Must be a straight flush and contain an Ace and 10\n  if (isStraightFlush(cards)) {\n    for (var i = 0; i < cards.length; i++) {\n      if (cards[i].includes(\"A\")) {\n        for (var j = 0; j < cards.length; j++) {\n          if (cards[j].includes(\"0\")) {\n            score +=\n              rank.indexOf(\"Royal Flush\") * 1000000 +\n              values.indexOf(\"A\") +\n              values.indexOf(\"K\") +\n              values.indexOf(\"Q\") +\n              values.indexOf(\"J\") +\n              values.indexOf(\"0\");\n            return [true, score];\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Check if given cards represent a straight flush\nexport const isStraightFlush = (cards) => {\n  let score = 0;\n  // Must be a straight and a flush\n  if (isFlush(cards) && isStraight(cards)) {\n    score += rank.indexOf(\"Straight Flush\") * 1000000;\n    for (var i = 0; i < cards.length; i++) {\n      score += values.indexOf(cards[i].substr(0, 1));\n    }\n    return [true, score];\n  }\n  return false;\n};\n\n// Check if given cards represent a four of a kind\nexport const isFourOfAKind = (cards) => {\n  let score = 0;\n  // Add all the values of the cards to array 'vals'\n  var vals = [];\n  for (var i = 0; i < cards.length; i++) {\n    vals.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  // Create a set from array 'vals'\n  var set = new Set(vals);\n  // Can only be four of a kind if size of set is 2\n  if (set.size === 2) {\n    var uniqueVals = Array.from(set);\n    // If one of the elements occurs 4 times then it is four of a kind\n    for (var k = 0; k < uniqueVals.length; k++) {\n      var valCount = 0;\n      for (var j = 0; j < vals.length; j++) {\n        if (vals[j] === uniqueVals[k]) valCount++;\n        if (valCount === 4) {\n          score += rank.indexOf(\"Four of a kind\") * 1000000;\n          for (var l = 0; l < vals.length - 1; l++) {\n            if (vals[l] === vals[l + 1]) {\n              score += vals[l] * 1000;\n              break;\n            }\n          }\n          score +=\n            vals[vals.length - 1] * 20 +\n            vals[vals.length - 2] * 10 +\n            vals[vals.length - 3] * 7 +\n            vals[vals.length - 4] * 5 +\n            vals[vals.length - 5] * 2;\n          return [true, score];\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Check if given cards represent a full house\nexport const isFullHouse = (cards) => {\n  let score = 0;\n  // Add all the values of the cards to array 'vals'\n  var vals = [];\n  for (var i = 0; i < cards.length; i++) {\n    vals.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  // Create a set from array 'vals'\n  var set = new Set(vals);\n  // Can only be full house if size of set is 2\n  if (set.size === 2) {\n    var uniqueVals = Array.from(set);\n    // If one of the elements occurs 3 times then it is full house\n    for (var k = 0; k < uniqueVals.length; k++) {\n      var valCount = 0;\n      for (var j = 0; j < vals.length; j++) {\n        if (vals[j] === uniqueVals[k]) valCount++;\n        if (valCount === 3) {\n          score += rank.indexOf(\"Full House\") * 1000000;\n          for (var l = 0; l < vals.length - 2; l++) {\n            if ((vals[l] === vals[l + 1]) === vals[l + 2]) {\n              score += vals[l] * 1000;\n              break;\n            }\n          }\n          score +=\n            vals[vals.length - 1] * 20 +\n            vals[vals.length - 2] * 10 +\n            vals[vals.length - 3] * 7 +\n            vals[vals.length - 4] * 5 +\n            vals[vals.length - 5] * 2;\n          return [true, score];\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Check if given cards represent a flush\nexport const isFlush = (cards) => {\n  let score = 0;\n  // Add all suits of the cards to array 'suits'\n  var suits = [];\n  for (var i = 0; i < cards.length; i++) {\n    suits.push(cards[i].substr(1));\n  }\n  // Create a set from array 'suits'\n  var set = new Set(suits);\n  // Can only be flush if size of set is 1\n  if (set.size === 1) {\n    score += rank.indexOf(\"Flush\") * 1000000;\n    for (var j = 0; j < cards.length; j++) {\n      score += values.indexOf(cards[j].substr(0, 1));\n    }\n    return [true, score];\n  } else return false;\n};\n\n// Check if given cards represent a straight\nexport const isStraight = (cards) => {\n  let score = 0;\n  // Add indices of values of all cards to array 'indices'\n  var indices = [];\n  for (var i = 0; i < cards.length; i++) {\n    indices.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  // Sort 'indices'\n  indices.sort(function (a, b) {\n    return a - b;\n  });\n  // Check if it is a wheel straight\n  var wheel = [0, 1, 2, 3, 12];\n  if (\n    indices.length === wheel.length &&\n    indices.every((value, index) => value === wheel[index])\n  ) {\n    score += rank.indexOf(\"Straight\") * 1000000 + 3;\n    return [true, score];\n  }\n  // If not a wheel straight determine if it's a regular straight\n  // In order to be a regular straight value at index + 1 must be 1 greater than value at index\n  for (var j = 0; j < indices.length - 1; j++) {\n    if (indices[j] + 1 !== indices[j + 1]) return false;\n  }\n  score += rank.indexOf(\"Straight\") * 1000000 + indices[indices.length - 1];\n  return [true, score];\n};\n\n// Check if given cards represent trips\nexport const isTrips = (cards) => {\n  let score = 0;\n  // Add all the values of the cards to array 'vals'\n  var vals = [];\n  for (var k = 0; k < cards.length; k++) {\n    vals.push(values.indexOf(cards[k].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  // Create a set from array 'vals'\n  var set = new Set(vals);\n  // Can only be trips if size of set is 3\n  if (set.size === 3) {\n    var uniqueVals = Array.from(set);\n    // If one of the elements occurs 3 times then it is trips\n    for (var i = 0; i < uniqueVals.length; i++) {\n      var valCount = 0;\n      for (var j = 0; j < vals.length; j++) {\n        if (vals[j] === uniqueVals[i]) valCount++;\n        if (valCount === 3) {\n          score += rank.indexOf(\"Three of a kind\") * 1000000;\n          for (var l = 0; l < vals.length - 1; l++) {\n            if (vals[l] === vals[l + 1]) {\n              score += vals[l] * 1000;\n              break;\n            }\n          }\n          score +=\n            vals[vals.length - 1] * 20 +\n            vals[vals.length - 2] * 10 +\n            vals[vals.length - 3] * 7 +\n            vals[vals.length - 4] * 5 +\n            vals[vals.length - 5] * 2;\n          return [true, score];\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Check if given cards represent two pair\nexport const isTwoPair = (cards) => {\n  let score = 0;\n  // Add all the values of the cards to array 'vals'\n  var vals = [];\n  for (var i = 0; i < cards.length; i++) {\n    vals.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  // Create a set from array 'vals'\n  var set = new Set(vals);\n  // Can only be two pair of size of set is 3\n  if (set.size === 3) {\n    // Since we already checked for trips in function that called this function, the only other hand with set of size 3 is two pair\n    score += rank.indexOf(\"Two pair\") * 1000000;\n    for (var j = 0; j < vals.length - 1; j++) {\n      if (vals[j] === vals[j + 1]) score += vals[j] * 1000;\n    }\n    score +=\n      vals[vals.length - 1] * 20 +\n      vals[vals.length - 2] * 10 +\n      vals[vals.length - 3] * 7 +\n      vals[vals.length - 4] * 5 +\n      vals[vals.length - 5] * 2;\n    return [true, score];\n  }\n  return false;\n};\n\n// Check if given cards represent a pair\nexport const isPair = (cards) => {\n  let score = 0;\n  // Add all the values of the cards to array 'vals'\n  var vals = [];\n  for (var i = 0; i < cards.length; i++) {\n    vals.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  // Create a set from array 'vals'\n  var set = new Set(vals);\n  // Can only be a pair of size of set is 4\n  if (set.size === 4) {\n    score += rank.indexOf(\"Pair\") * 1000000;\n    for (var j = 0; j < vals.length - 1; j++) {\n      if (vals[j] === vals[j + 1]) score += vals[j] * 1000;\n    }\n    score +=\n      vals[vals.length - 1] * 20 +\n      vals[vals.length - 2] * 10 +\n      vals[vals.length - 3] * 7 +\n      vals[vals.length - 4] * 5 +\n      vals[vals.length - 5] * 2;\n    return [true, score];\n  }\n  return false;\n};\n\n// Evaluate score for high card\nexport const highCard = (cards) => {\n  let score = 0;\n  var vals = [];\n  for (var i = 0; i < cards.length; i++) {\n    vals.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  vals.sort(function (a, b) {\n    return a - b;\n  });\n  score +=\n    vals[vals.length - 1] * 1000 +\n    vals[vals.length - 2] * 500 +\n    vals[vals.length - 3] * 250 +\n    vals[vals.length - 4] * 100 +\n    vals[vals.length - 5] * 50;\n  return score;\n};\n\n// Method to determine action for bot on river\nexport const botRiver = (\n  botCards,\n  flop,\n  turn,\n  river,\n  position,\n  stackSize,\n  betOutstanding,\n  betAmount,\n  potSize\n) => {\n  // Evaluate bot cards\n  const [rank, hand, score] = evaluateRiver(botCards, flop, turn, river);\n  var cards = [];\n  for (var i = 0; i < 3; i++) cards.push(flop[i].code);\n  cards.push(turn[0].code);\n  cards.push(river[0].code);\n  let nutScore = 0;\n  // Find nut hand\n  for (var j = 0; j < 5; j++) {\n    var tempCards = cards.slice();\n    tempCards.splice(j, 1);\n    if (getNutHand(tempCards) > nutScore) nutScore = getNutHand(tempCards);\n  }\n\n  // Compare bot hand to nut hand\n  const ratio = score / nutScore;\n\n  // Return bot decision based on ratio\n  return botDecision(\n    ratio,\n    position,\n    betOutstanding,\n    stackSize,\n    betAmount,\n    potSize\n  );\n};\n\n// Method to determine action for bot on turn\nexport const botTurn = (\n  botCards,\n  flop,\n  turn,\n  position,\n  stackSize,\n  betOutstanding,\n  betAmount,\n  potSize\n) => {\n  // Evaluate bot cards\n  const [rank, hand, score] = evaluateTurn(botCards, flop, turn);\n  var cards = [];\n  for (var i = 0; i < 3; i++) cards.push(flop[i].code);\n  cards.push(turn[0].code);\n  let nutScore = 0;\n  // Find nut hand\n  for (var j = 0; j < 4; j++) {\n    var tempCards = cards.slice();\n    tempCards.splice(j, 1);\n    if (getNutHand(tempCards) > nutScore) nutScore = getNutHand(tempCards);\n  }\n\n  // Compare bot hand to nut hand\n  const ratio = score / nutScore;\n\n  // Return bot decision based on ratio\n  return botDecision(\n    ratio,\n    position,\n    betOutstanding,\n    stackSize,\n    betAmount,\n    potSize\n  );\n};\n\n// Method to determine action for bot on flop\nexport const botFlop = (\n  botCards,\n  flop,\n  position,\n  stackSize,\n  betOutstanding,\n  betAmount,\n  potSize\n) => {\n  // Evaluate bot cards\n  const [rank, score, hand] = evaluateFlop(botCards, flop);\n  var cards = [];\n  for (var i = 0; i < 3; i++) cards.push(flop[i].code);\n  // Get nut hand\n  const nutScore = getNutHand(cards);\n  // Compare bot hand to nut hand\n  const ratio = score / nutScore;\n\n  // Return bot decision based on ratio\n  return botDecision(\n    ratio,\n    position,\n    betOutstanding,\n    stackSize,\n    betAmount,\n    potSize\n  );\n};\n\n// Method to determine action for bot preflop\nexport const botPre = (\n  cards,\n  position,\n  stackSize,\n  betOutstanding,\n  betAmount,\n  potSize\n) => {\n  // Calculate strength of hand using Chen formula\n  var chenValues = [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 10];\n  var score = 0;\n  if (cards[0].substr(0, 1) === cards[1].substr(0, 1)) {\n    score = Math.min(5, 2 * chenValues[values.indexOf(cards[0].substr(0, 1))]);\n  } else {\n    score += Math.max(\n      chenValues[values.indexOf(cards[0].substr(0, 1))],\n      chenValues[values.indexOf(cards[1].substr(0, 1))]\n    );\n    if (cards[0].substr(1, 2) === cards[1].substr(1, 2)) score += 2;\n    let gap = Math.abs(\n      values.indexOf(cards[0].substr(0, 1)) -\n        values.indexOf(cards[1].substr(0, 1))\n    );\n    if (gap === 2) score -= 1;\n    else if (gap === 3) score -= 2;\n    else if (gap === 4) score -= 4;\n    else if (gap >= 5) score -= 5;\n\n    if (\n      Math.max(\n        chenValues[values.indexOf(cards[0].substr(0, 1))],\n        chenValues[values.indexOf(cards[1].substr(0, 1))]\n      ) < 7\n    ) {\n      if (gap <= 2) score += 1;\n    }\n  }\n  // Normalize score by dividing by max amount (pocket aces = 20)\n  score = Math.max(0, Math.ceil(score) / 20);\n\n  // Return bot decision based on chen formula score\n  return botDecision(\n    score,\n    position,\n    betOutstanding,\n    stackSize,\n    betAmount,\n    potSize\n  );\n};\n\n// Method to determine bot decision given various variables and factors\nexport const botDecision = (\n  score,\n  position,\n  betOutstanding,\n  stackSize,\n  betAmount,\n  potSize\n) => {\n  // 'decision' will hold bot action\n  // 'raiseAmount' will hold raise amount if bot decides to raise\n  let decision = \"\";\n  let raiseAmount = 0;\n  // If no betOutstanding\n  if (betOutstanding === 0) {\n    // Generate random number to determine whether to raise based on score, lower the score the lower the likelihood of raising\n    if (Math.random() < score) {\n      decision = \"r\";\n      if (betAmount !== 0) raiseAmount = Math.min(stackSize, betAmount * 2.5);\n      else raiseAmount = Math.min(stackSize, potSize * 0.5);\n    }\n    // Otherwise just check\n    else {\n      decision = \"k\";\n    }\n  }\n  // If there is a bet\n  else {\n    // If bot is in position\n    if (position === 0) {\n      // Break up decision based on different thresholds for score, and generate random numbers using different weighted probabilities based on those scores to determine whether to fold, call, or raise *CURRENTLY ONLY RAISES BY A CONSTANT AMOUNT*\n      if (score < 0.15) {\n        if (Math.random() < 0.6) decision = \"f\";\n        else if (Math.random() < 0.5) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else if (score < 0.35) {\n        if (Math.random() < 0.1) decision = \"f\";\n        else if (Math.random() < 0.4) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else if (score < 0.5) {\n        if (Math.random() < 0.3) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else {\n        if (Math.random() < 0.5) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      }\n    }\n    // If bot in BB\n    else {\n      if (score < 0.15) {\n        if (Math.random() < 0.7) decision = \"f\";\n        else if (Math.random() < 0.5) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else if (score < 0.35) {\n        if (Math.random() < 0.2) decision = \"f\";\n        else if (Math.random() < 0.4) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else if (score < 0.5) {\n        if (Math.random() < 0.4) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      } else {\n        if (Math.random() < 0.5) decision = \"c\";\n        else {\n          decision = \"r\";\n          if (betAmount !== 0)\n            raiseAmount = Math.min(stackSize, betAmount * 2.5);\n          else raiseAmount = Math.min(stackSize, potSize * 0.5);\n        }\n      }\n    }\n  }\n  return [decision, raiseAmount];\n};\n\n// Method to get nut hand at any juncture\nexport const getNutHand = (cards) => {\n  var score = 0;\n  var vals = [];\n  for (var i = 0; i < 4; i++) {\n    vals.push(values.indexOf(cards[0].substr(0, 1)));\n  }\n\n  const [straightPotential, straightScore] = hasStraightPotential(cards);\n\n  // Check for various possible hands, score each one, and return the highest score = nut hand\n  if (hasFlushPotential(cards)) {\n    if (straightPotential) {\n      if (straightScore === 50) {\n        // Royal flush\n        score += rank.indexOf(\"Royal Flush\") * 1000000 + straightScore;\n      } else {\n        // Straight flush\n        score += rank.indexOf(\"Straight Flush\") * 1000000 + straightScore;\n      }\n    } else {\n      // Flush\n      score += rank.indexOf(\"Flush\") * 1000000;\n      for (var i = 0; i < cards.length; i++) {\n        score += values.indexOf(cards[i].substr(0, 1));\n      }\n      vals.sort(function (a, b) {\n        return a - b;\n      });\n      var newValues = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n      newValues = newValues.filter((el) => !vals.includes(el));\n      score +=\n        newValues[newValues.length - 1] + newValues[newValues.length - 2];\n    }\n  } else if (straightPotential) {\n    // Straight\n    score += rank.indexOf(\"Straight\") * 1000000 + (straightScore + 10) / 5;\n  } else if (isThreeOfTheSame(cards)) {\n    // Four of a kind\n    score +=\n      rank.indexOf(\"Four of a kind\") * 1000000 +\n      values.indexOf(cards[0].substr(0, 1)) * 1000;\n    if (cards[0].substr(0, 1) !== 12) {\n      score += 12 * 20 + vals[0] * 24;\n    } else {\n      score += 526;\n    }\n  } else if (hasPair(cards)) {\n    // Four of a kind\n    score += rank.indexOf(\"Four of a kind\") * 1000000;\n    var vals = [];\n    const fourOfAKind = 0;\n    for (var i = 0; i < vals.length - 1; i++) {\n      if (vals[i] === vals[i + 1]) score += vals[i] * 1000;\n      fourOfAKind = vals[i];\n    }\n    vals.push(fourOfAKind);\n    vals.push(fourOfAKind);\n    vals.sort(function (a, b) {\n      return a - b;\n    });\n    score +=\n      vals[vals.length - 1] * 20 +\n      vals[vals.length - 2] * 10 +\n      vals[vals.length - 3] * 7 +\n      vals[vals.length - 4] * 5 +\n      vals[vals.length - 5] * 2;\n  } else {\n    vals.sort(function (a, b) {\n      return a - b;\n    });\n    // Three of a kind\n    score += rank.indexOf(\"Three of a kind\") * 1000000;\n    vals.push(vals[vals.length - 1]);\n    vals.push(vals[vals.length - 1]);\n    score +=\n      vals[vals.length - 1] * 20 +\n      vals[vals.length - 2] * 10 +\n      vals[vals.length - 3] * 7 +\n      vals[vals.length - 4] * 5 +\n      vals[vals.length - 5] * 2;\n  }\n\n  return score;\n};\n\n// Method to determine if all 3 cards are the same\nexport const isThreeOfTheSame = (cards) => {\n  for (var i = 0; i < 2; i++) {\n    if (cards[i].substr(0, 1) !== cards[i + 1].substr(0, 1)) return false;\n  }\n  return true;\n};\n\n// Method to determine if there is a pair among the three cards\nexport const hasPair = (cards) => {\n  for (var i = 0; i < 2; i++) {\n    if (cards[i].substr(0, 1) === cards[i + 1].substr(0, 1)) return true;\n  }\n  return false;\n};\n\n// Method to determine if all three cards have same suit\nexport const hasFlushPotential = (cards) => {\n  for (var i = 0; i < 2; i++) {\n    if (cards[i].substr(1, 2) !== cards[i + 1].substr(1, 2)) return false;\n  }\n  return true;\n};\n\n// Method to determine if it is possible to have a straight with the given three cards\nexport const hasStraightPotential = (cards) => {\n  var indices = [];\n  for (var i = 0; i < cards.length; i++) {\n    indices.push(values.indexOf(cards[i].substr(0, 1)));\n  }\n  indices.sort();\n  if (indices[2] === 12 && indices[0] < 4 && indices[1] < 4) return [true, 18];\n  else {\n    var gap = 0;\n    for (var i = 0; i < indices.length - 1; i++) {\n      gap += indices[i + 1] - indices[i];\n    }\n    if (gap === 4)\n      return [\n        true,\n        indices[2] +\n          (indices[2] - 1) +\n          indices[1] +\n          (indices[1] - 1) +\n          indices[0],\n      ];\n    else if (gap === 3) {\n      var highCard = Math.min(indices[2] + 1, 12);\n      var score = 5 * highCard - 10;\n      return [true, score];\n    } else if (gap === 3) {\n      var highCard = Math.min(indices[2] + 2, 12);\n      var score = 5 * highCard - 10;\n      return [true, score];\n    }\n  }\n  return [false, -1];\n};\n\n// // Method to determine if there is a straight draw\n// export const hasStraightDraw = (cards) => {\n//   // Only look for draw if there is no straight already\n//   if (!isStraight(cards)){\n//     var indices = [];\n//     for (var i = 0; i < cards.length; i++){\n//       indices.push(values.indexOf(cards[i].substr(0, 1)));\n//     }\n//     indices.sort(function (a, b) {\n//       return a - b;\n//     });\n//     let gap = 0;\n//     for (var j = 0; j < indices.length - 1; j++){\n//       gap += indices[j + 1] - indices[j];\n//     }\n\n//   }\n// }\n",{"ruleId":"59","replacedBy":"60"},{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","severity":1,"message":"64","line":434,"column":10,"nodeType":"65","messageId":"66","endLine":434,"endColumn":14},{"ruleId":"63","severity":1,"message":"67","line":434,"column":16,"nodeType":"65","messageId":"66","endLine":434,"endColumn":20},{"ruleId":"63","severity":1,"message":"64","line":473,"column":10,"nodeType":"65","messageId":"66","endLine":473,"endColumn":14},{"ruleId":"63","severity":1,"message":"67","line":473,"column":16,"nodeType":"65","messageId":"66","endLine":473,"endColumn":20},{"ruleId":"63","severity":1,"message":"64","line":510,"column":10,"nodeType":"65","messageId":"66","endLine":510,"endColumn":14},{"ruleId":"63","severity":1,"message":"67","line":510,"column":23,"nodeType":"65","messageId":"66","endLine":510,"endColumn":27},{"ruleId":"68","severity":1,"message":"69","line":713,"column":16,"nodeType":"65","messageId":"70","endLine":713,"endColumn":17},{"ruleId":"68","severity":1,"message":"71","line":740,"column":9,"nodeType":"65","messageId":"70","endLine":740,"endColumn":13},{"ruleId":"68","severity":1,"message":"69","line":742,"column":14,"nodeType":"65","messageId":"70","endLine":742,"endColumn":15},{"ruleId":"72","severity":1,"message":"73","line":744,"column":7,"nodeType":"65","messageId":"74","endLine":744,"endColumn":18},{"ruleId":"68","severity":1,"message":"69","line":810,"column":14,"nodeType":"65","messageId":"70","endLine":810,"endColumn":15},{"ruleId":"68","severity":1,"message":"75","line":827,"column":11,"nodeType":"65","messageId":"70","endLine":827,"endColumn":19},{"ruleId":"68","severity":1,"message":"76","line":828,"column":11,"nodeType":"65","messageId":"70","endLine":828,"endColumn":16},"no-native-reassign",["77"],"no-negated-in-lhs",["78"],"no-unused-vars","'rank' is assigned a value but never used.","Identifier","unusedVar","'hand' is assigned a value but never used.","no-redeclare","'i' is already defined.","redeclared","'vals' is already defined.","no-const-assign","'fourOfAKind' is constant.","const","'highCard' is already defined.","'score' is already defined.","no-global-assign","no-unsafe-negation"]